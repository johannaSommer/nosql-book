%!TEX root = ../main.tex

\chapter{GraphDB}
\chapterauthor{Thore Kr√ºss, Lennart Purucker, Johanna Sommer}

\section{Motivation/Introduction}
First paragraph to state the general context and make important points for the motivation and why its important. Refer to Wood Paper here.

But Graph Database research has its beginnings already in the early 90s. During this time, numerous proposals came up, describing a semantic network to store data about the database. That was, because contemporary systems were failing to take into account the semantics of a database.
The Locial Data Model \autocite{KUPERLDM} was proposed, trying to combine the advantages of relational, hierarchical and network approaches in that they modeled databases as directed graphs, with leaves representing attributes and internal nodes posing as connections between the data. \\
Similar to that, the Functional Data Model \autocite{Shipman1979} was proposed with the same goal, focusing specifically on providing a conceptually natural database interface \autocite{Angles2018AnIT}. \\
During this period, most of the underlying theory of Graph Databases was created.
It was most likely because of insufficient hardware support for big graphs that this research declined, only to be picked up again now, powered by improved hardware. Todays focus in Graph Theory research lies primarily on actual practical systems and on the theoretical analysis of graph query languages \autocite{Angles2018AnIT}.

Especially practical implementations of Graph Database Theory have gained traction, as real world problems are more often than not interrelated - hence graphs are extremely useful in unterstanding the wide diversity of real-world datasets \autocite{Robinson2013}. \\
The emerging of social networks have naturally helped graph database models come up, with big players like Twitter and their implementation FlockDB entering the field. In those social network situations, a so-called social graph can effortlessly model attributes of a person as well as relationships between people. While in traditional RDBMS the apparent friend-of-a-friend-problem would be solved with a join over all relevant tables, in graph database technology this can be achieved with a traversal, which is far more cost inexpensive \autocite{Miller2013GraphDA}. \\
Another meaningful topic today are recommender systems, where most work focusing on optimizing machine learning algorithms. But also in database theory, this specific context poses challenges. However again, the graph model gracefully maps item similarities and correlations between user behaviour \autocite{Huang2002}.

These application fields bring very distinct workloads that require specific query languages to process. There are two different kinds of workload: in social network transactions low-latency online graphs are processed while for example link analysis algorithms evaluate high-throughput offline graphs \autocite{Angles2018AnIT}. Many query language proposals have come up recently, differing mainly in the underlying graph data structure/model and the functionality provided \autocite{Wood2012QueryLF}.

A deeper description of the theory behind graph databases will be given in subsection 2, aiming to connect the data model to its fields of application as well as comparing it to RDBMS. This comparison will be picked up in subsection 3, where a use case from the SQL world will be applied to Graph Database Theory, focusing in particular on Neo4j. Lastly, our findings will be stated in subsection 4 with a general conclusion.


\section{Graph Database Theory}
\subsection{Description of data model and functionality}
\subsection{fields of application}
\subsection{CAP Theorem}
\subsection{Comparison: Graph Databases and Relational Databases}
As the comparison between Graph Databases and Relational Databases is a known field, a lot of literature exists on this topic already. Throughout the comparisons, the two methods are always assessed under the same aspects: performance, flexibility, security and maturity. \\
For those comparison points it makes sense to focus on specific implementations of the technologies, hence in this section Neo4j will be chosen as a concrete precedent for Graph Databases, whereas MySQL will be the example implementation for Relational Databases.

\subsubsection{Performance}
Detailed surveys on performance of both technologies already exist in literature, for example from Vicknais et al. \autocite{Vicknair2010}. In this specific instance, MySQL version 5.1.42 and Neo4j-b11 were compared.
The queries chosen for the experiments were similar to types that are used in real world provenance systems. Typically in this scenario, for one dataset/node one traverses the graph to find its origin. Another use case in this context is, if a data object or node is deemed incorrect, this information needs to be propagated to all its descendants/child nodes \autocite{Vicknair2010}.\\
Further on, the queries were partitioned into structural queries referencing the graph but not the payload itsself, and data queries using the actual payload data. It is important to note that the payload data in this case was integer payload data, as different types are handled seperately depending on framework.\\
In the traversal queries, Neo4j clearly outperformed MySQL, sometimes even being faster by the factor of 10. Though that was expected, as Relational Databases are not designed for traversals. MySQL for this part of experiment falls back to a standard Breath First Search, which is not optimal for this scenario. Neo4j on the other hand has a built in framework for traversals, making it superior in terms of performance for the traversal queries \autocite{Vicknair2010}. \\
Contrary to that, in the data queries MySQL turned out to be more efficient. This result was partly due to the fact that Neo4j uses Lucene for querying, which treats all payload as text, eventhough in this scenario the payload is of type integer. But also when the payload changes to text, MySQL had better performance in the experiments \autocite{Vicknair2010}. \\
The researchers also took into account a special case for the experiments, trying the data queries with payload that is closer to actual real world data - text with spaces inbetween the words. Surprisingly, at a large enough scale Nao4j outperformed MySQL by a large amount for those queries.

\subsubsection{Flexibility}
The flexibility aspect compares both database technologies in their behaviour when taken out of the environment that they were created for \autocite{Vicknair2010}. \\
For Relational Databases an uncommon environment would for example be ad-hoc data schemes that change with time, whereas for Graph Databases a less typical dataset would be one without many connections between the individual nodes  \autocite{GarimaAnalysis}.
MySQL is optimized for a large-scale multi-user environment, hence trying to use it for smaller applications comes with a large overhead of functionality that has to be implemented with it but that may not even be needed for this specific application.
Neo4j is typically targeted towards more lightweight applications, but manages to scale really well, having a scalable architecture that also accounts for speed \autocite{neo4jweb}. Its easily mutable schema makes it more flexible with data types that are rather untypical for Graph Databases.

\subsubsection{Security}
Neo4j does not have built in mechanisms for managing security restrictions and multiple users \autocite{GarimaAnalysis}. MySQL on the other hand natively supports multiple users as well as access control lists. \autocite{mysqlsecurity}

\subsubsection{Maturity}
For the comparison under the aspect of maturity it makes sense to talk about database implementations in general. Maturity refers both to how old a particular system is and to how thoroughly tested it is \autocite{Vicknair2010}.
Since all Relational databases - inclusing MySQL - use the same query language SQL, support is equal over all implementations and support for one implementation is applicable to all others \autocite{GarimaAnalysis}.
Neo4js version 1.1 was released in February 2010. While Neo4j is a for-profit framework and has decent support from its parenty company, this does not apply to all graph database implementations \autocite{Vicknair2010}. Furthermore, the query languages differ from implementation to implementation, separating them in that aspect and not sharing support??.


\section{Implementing a Graph Database Model}
This section shall outline the general approach how to convert an existing relational database model into property graph model.
In the second part an introdcution to Neo4j, the implementation of a database model in Python and basic querying in an application and with Neo4js own query language \glqq Cypher\grqq{} will follow.

\subsection{Converting a Relational Database Model}
There are a couple of guides available describing how to build a database model for Neo4j. Since the database itself is schema-less multiple schemas can be used and implemented at the same time.
Nevertheless an application needs a model of the data.
Neo4j states in \autocite{neo4j:rel_to_graph} that it is possible to transfer almost all existing relational models into a graph model.
The general approach has been described in \autocite{dzone:rel_to_graph}.
The first step in this conversion is to consider the names of all Non-JOIN-Tables as labels.
Foreign keys will become relations.
JOIN-Tables become relations as well with additional properties added to the relation \autocite{neo4j:graph_vs_rdbms}.
The rows will be converted into nodes connected by edges based on the formerly converted relations. Attributes not covered in the previous steps will become properties of a node.

\subsection{Implementing a sample project with Neo4j}
In this section the modeling and setup with Neo4j should be lined out and a sample project be described utilizing available Python-Libraries to implement a sample project.
There are two different available versions of Neo4j.
First of all there is the Open Source community edition which is published under the GPL.
Additionally Neo4j Inc sells licences for an enterprise edition \autocite{neo4j:editions} including support and several additional features, such as replication, multiple users, several query perfomance optimization and no limitation for the number of nodes in the database (the community version is limited at 34 Billion nodes).
The following examples have been implemented and tested with the community edition.

\subsubsection{Setting up Neo4j}
Neo4j is available for Windows, Linux and Mac and can be installed via the provided packages. While there is a minimum requirement of 2GB of RAM Neo4j recommends 16GB or more \autocite[Chapter~2.1]{neo4j:op_manual}.
Since Neo4j ist implemented in Java starting it can be done by invoking it with a Java runtime of choice installed. The default configuration does not need to be modified to get started.

\paragraph{High availability} The community edition of Neo4j does not allow to set up a cluster of multiple Neo4j instances. This feature es reserved for the enterprise version. The setup of a causally consistent cluster is explained in the documentation \autocite[Chapter~5.1]{neo4j:op_manual}. The reference architecture as shown in \autoref{fig:graphdb:causal_cluster} recommends an odd number of at least three \glqq Core Servers\grqq{} connected into a RAFT-Cluster handling mostly write requests. They ensure consistency of the data. Connected to these core cluster may be an arbitrary number of \glqq Read Servers\grqq. They only handle the, sometimes ressource costly, read requests but are not relevant to the clusters integrity. Information from Core Servers is replicated asynchronously to the read replicas.
\begin{figure}[ht]
    \centering
    \includegraphics[width=.5\textwidth]{img/causal_clustering.png}
    \caption{Neo4j causal Cluster Architecture \autocite[Chapter~5.1]{neo4j:op_manual}}
    \label{fig:graphdb:causal_cluster}
\end{figure}

\subsubsection{Modeling the graph database}
The sample project maps the relations within users in a social network.
As it can be seen in \autoref{fig:graphdb:graphmodel} there may be an arbitrary number of Persons (orange) who may be friends with other persons.
Additionally they can share interests (green) and may be a member of a group (purple).
Forthermore they can state from which country (yellow) they are from.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        \node[draw, circle, fill=orange, minimum height=1.5cm, minimum width=1.5cm] (alice) {Alice};
        \node[draw, circle, fill=orange, minimum height=1.5cm, minimum width=1.5cm] (bob)  at ([xshift=-2.5cm, yshift=-2.5cm]alice.south) {Bob};
        \node[draw, circle, fill=orange, minimum height=1.5cm, minimum width=1.5cm] (carol)  at ([xshift=2.5cm, yshift=-2.5cm]alice.south) {Carol};

        \node[draw, circle, fill=green, minimum height=1.5cm, minimum width=1.5cm] (db) at ([xshift=5cm, yshift=-0.5cm]alice.east) {\tiny Databases};

        \node[draw, circle, fill=purple, minimum height=1.5cm, minimum width=1.5cm, align=center] (eff) at ([xshift=2.5cm, yshift=-2cm]bob.south) {\scriptsize EFF};

        \node[draw, circle, fill=yellow, minimum height=1.5cm, minimum width=1.5cm] (uk) at ([xshift=-2cm, yshift=2.5cm]bob.west) {\scriptsize UK};
        \node[draw, circle, fill=yellow, minimum height=1.5cm, minimum width=1.5cm] (ire) at ([xshift=4cm]carol.east) {\scriptsize Ireland};



        \draw [<->, thick] (alice) -- (bob) node[midway,sloped, above] {{\scriptsize FRIENDS\char`_WITH}};

        \draw [<->, thick] (bob) -- (carol) node[midway,sloped, above] {\scriptsize FRIENDS\char`_WITH};

        \draw [->, thick] (alice) -- (db) node[midway,sloped, above] {\scriptsize INTERESTED\char`_IN};
        \draw [->, thick] (carol) -- (db) node[midway,sloped, above] {\scriptsize INTERESTED\char`_IN};

        \draw [->, thick] (bob) -- (eff) node[midway,sloped, above] {\scriptsize IS\char`_MEMBER};
        \draw [->, thick] (carol) -- (eff) node[midway,sloped, above] {\scriptsize IS\char`_MEMBER};

        \draw [->, thick] (alice) -- (uk) node[midway,sloped, above] {{\scriptsize IS\char`_FROM}};
        \draw [->, thick] (carol) -- (ire) node[midway,sloped, above] {{\scriptsize IS\char`_FROM}};
        \draw [->, thick] (bob) -- (uk) node[midway,sloped, above] {{\scriptsize IS\char`_FROM}};

    \end{tikzpicture}
    \caption{Sample database schema}
    \label{fig:graphdb:graphmodel}
\end{figure}

\subsubsection{Implementation in Python}
While it is possible to manage the database utilizing the CRUD-functionality from Neo4js own query language Cypher (see \ref{sec:graphdb:cypher}) this is not really comfortable in an application.
Developers familiar with Object-Relational-Mappers (ORM) such as Hibernate for Java or SQLAlchemy for Python would prefer to define the different nodes and relations in classes providing the database elements as objects and abstracting actual SQL-Queries.

For Python there exists a community driven project called neomodel \autocite{github:neomodel} aiming to provide an Object-Graph-Mapper (OGM) for Python projects. Neomodel is published under the MIT License.

\begin{listing}[ht]
    \begin{minted}{python}
    class Partnership(StructuredRel):
        since = DateTimeProperty(
            default=lambda: datetime.now(pytz.utc)
        )

    class Country(StructuredNode):
        name = StringProperty(unique_index=True, required=True)

    class Interest(StructuredNode):
        name = StringProperty(unique_index=True, required=True)

    class Group(StructuredNode):
        name = StringProperty(unique_index=True, required=True)

    class Person(StructuredNode):
        uid = UniqueIdProperty()
        name = StringProperty(unique_index=True)
        age = IntegerProperty(index=True, default=0)

        # traverse outgoing relations
        country = RelationshipTo(Country, 'IS_FROM')
        interests = RelationshipTo(Interest, 'IS_INTERESTED_IN')
        groups = RelationshipTo('Group', 'IS_MEMBER')
        friends = Relationship('Person', 'FRIENDS_WITH', model=Partnership)
    \end{minted}
    \caption{Example graph database model with neomodel}
    \label{lst:graphdb:neomodel}
\end{listing}

The implementation of the graph model mentioned in \autoref{fig:graphdb:graphmodel} in python has been realized in \autoref{lst:graphdb:neomodel} following the neomodel documentation \autocite{neomodel:rtd}. With this model it is possible to create new nodes in the database by instatiating a new object of the given classes as in \autoref{lst:graphdb:createPerson}.
\begin{listing}[H]
\begin{minted}{python}
lmeitner = Person(name='Lise Meitner', age=89)
lmeitner.save()
\end{minted}
\caption{Creating a new person node in the database}
\label{lst:graphdb:createPerson}
\end{listing}

To connect two nodes it is necessary to get both objects and to invoke the \texttt{connect()} method as seen in \autoref{lst:graphdb:connectNodes} on one of them.
The \texttt{get\char`_or\char`_create} method simplifies creation of nodes with no additional properties since it either returns an already existing node or creates it.
\begin{listing}[H]
\begin{minted}{python}
country = Country.get_or_create({'name': 'Austria'})
lmeitner.country.connect(country[0])
\end{minted}
\caption{Connecting a person and a country node}
\label{lst:graphdb:connectNodes}
\end{listing}

Retreiving one or more existing nodes can be done by filtering as shown in \autoref{lst:graphdb:queryPerson}.
\begin{listing}[H]
\begin{minted}{python}
curie = Person.nodes.filter(name='Marie Curie')
\end{minted}
\caption{Querying for a person node by the name attribute}
\label{lst:graphdb:queryPerson}
\end{listing}

\subsubsection{Queries using Cypher}
\label{sec:graphdb:cypher}
Neo4j provides its own query language Cypher. It is developed with an open source specification called openCypher \autocite{openCypher}.
Thus it should be possible to use the same query language for graph processing in other databases -- such as SAP HANA or Redis.
Its syntax is oriented on SQL statements though there are quite some differences to better match into a graph model.
Neo4j has an extensive introduction how to use Cypher \autocite{neo4j:cypher_introduction}.
Therefore only a short introduction should be given here.

Cypher uses two basic patterns.
First of all there are nodes.
They are denoted by enclosing parentheses.
The second pattern is used for relationships.
They are expressed by two dashes and may have a direction utilizing the greater-than/less-than signs.
Furthermore the type of a relationship may be specified in brackets between the two dashes.

A few examples will make it easier to understand how these patterns can be used.

The most simple query would be to get all nodes and all relations between them withouth regard to their labels.
This can be achieved by calling \mint{SQL}|MATCH (n) RETURN n|
It is important to note that Cypher uses \texttt{MATCH} as a keyword similar SQLs \texttt{SELECT}.
Contrary to SQL it is necessary is Cypher to \texttt{RETURN} the previously matched nodes to obtain them in the result.
It is possible to declare the label of a node by calling \mint{SQL}|MATCH (p:Person) RETURN p|
This would reduce the output to all persons and the relations between them.

As mentioned before Cypher supports a pattern for relations.
To include them in a query -- e.g. for all Persons who have one or more friends the query would look like \mint{SQL}|MATCH (a:Person) -[:FRIENDS_WITH]- (b:Person) RETURN a, b|
The relationship type in the brackets may be ommited to get all types of relations between these nodes.

Similar to SQL Cypher also supports a \texttt{WHERE} statement.
To query for a specific Person where the attribute \texttt{name} equals \glqq Otto Hahn\grqq{} and all nodes connected to this person the Cypher query would look like this \mint{SQL}|MATCH (p:Person)-[r]-(n) WHERE p.name = 'Otto Hahn' RETURN p, r, n|

Of course Cypher offers a complete keyword set for all types of CRUD operations. Interested readers should follow the fntroduction from Neo4j \autocite{neo4j:cypher_introduction}.

\subsection{Conclusion}
Getting started with Neo4j is pretty simple.
There is plenty of dpcumentation available helping to implement a database model and an application based on it.
Especially the OGM Projects for Python seem pretty advanced and suitable for production usage.
Users familiar with SQL will find Cypher not that difficult to get used to it.

There are two major downsides with Neo4j. The first one is the memory footprint.
A newly set up instance already consumes more than 600MB of RAM -- in comparison, a PostgreSQL instance storing a couple hundred MB of data still consumes less than half of that.
The second downside is, that many features -- especially regarding maintenance and clustering are preserved for the enterprise edition and not available in the open source community edition. This makes it difficult if not impossible to use the community edition in a production environment.

\section{Reflection}
\subsection{alternative popular graphdbs}
\subsubsection{OrientDB}
\subsection{conclusion}
reflect on advantages disadvantages with implementation references
