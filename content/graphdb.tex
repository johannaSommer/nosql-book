\chapter{GraphDB}
\chapterauthor{Thore Krüss, Lennart Purucker, Johanna Sommer}

\section{Motivation/Introduction}
First paragraph to state the general context and make important points for the motivation and why its important. Refer to Wood Paper here.

But Graph Database research has its beginnings already in the early 90s. During this time, numerous proposals came up, describing a semantic network to store data about the database. That was, because contemporary systems were failing to take into account the semantics of a database. (letzten Satz ändern)
The Locial Data Model \cite{KUPERLDM} was proposed, trying to combine the advantages of relational, hierarchical and network approaches in that they modeled databases as directed graphs, with leaves representing attributes and internal nodes posing as connections between the data. \\
Similar to that, the Functional Data Model \cite{Shipman1979} was proposed with the same goal, focusing specifically on providing a conceptually natural database interface \cite{Angles2018AnIT}. \\
During this period, most of the underlying theory of Graph Databases was created.
It was most likely because of insufficient hardware support for big graphs that this research declined, only to be picked up again now, powered by improved hardware. Todays focus in Graph Theory research lies primarily on actual practical systems and on the theoretical analysis of graph query languages \cite{Angles2018AnIT}.

Especially practical implementations of Graph Database Theory have gained traction, as real world problems are more often than not interrelated - hence graphs are extremely useful in unterstanding the wide diversity of real-world datasets.\cite{Robinson2013} \\
The emerging of social networks have naturally helped graph database models come up, with big players like Twitter and their implementation FlockDB entering the field. In those social network situations, a so-called social graph can effortlessly model attributes of a person as well as relationships between people. While in traditional RDBMS the apparent friend-of-a-friend-problem would be solved with a join over all relevant tables, in graph database technology this can be achieved with a traversal, which is far more cost inexpensive (letzten Teilsatz ändern) \cite{Miller2013GraphDA}. \\
Another meaningful topic today are recommender systems, where most work focusing on optimizing machine learning algorithms. But also in database theory, this specific context poses challenges. However again, the graph model gracefully maps item similarities and correlations between user behaviour \cite{Huang2002}.

These application fields bring very distinct workloads that require specific query languages to process. There are two different kinds of workload: in social network transactions low-latency online graphs are processed while for example link analysis algorithms evaluate high-throughput offline graphs \cite{Angles2018AnIT}. Many query language proposals have come up recently, differing mainly in the underlying graph data structure/model and the functionality provided \cite{Wood2012QueryLF}.

A deeper description of the theory behind graph databases will be given in subsection 2, aiming to connect the data model to its fields of application as well as comparing it to RDBMS. This comparison will be picked up in subsection 3, where a use case from the SQL world will be applied to Graph Database Theory, focusing in particular on Neo4j. Lastly, our findings will be stated in subsection 4 with a general conclusion.


\section{Graph Database Theory}
\subsection{Description of data model and functionality}
\subsection{fields of application}
\subsection{CAP Theorem}
\subsection{GraphDB vs. RDBMS}
einleitung, there is lots of literature on it and the main comparison points seem to be: all literature typically uses neo4j and mysql because??

\subsubsection{performance}
in xx VIcknais et al. did a detailed performance survey. For that, mySQL version 5.1.42 and neo4j 1.0-b11hoch2 was compared. \cite{Vicknair2010}
The queries simulate the types that are used in provenance systems. So for one dataset or node, you traverse the graph to find out their herkunft. Similarily if a data object/node is marked as incorrect, this information needs to be propagated to all is descendants/child nodes.
The queries then were partitioned int structureal queries referencing the graph but not the paylos, an data queries using the payload data. integer payload data
For the traversal queries, S0, S4, and S128, Neo4j was clearly faster, sometimes by a factor of 10. Though relational databases are not designed to do traversals. Neo4j also has a built in framework for traversals whereas mysql used a standard breadth first search.
in the data queries mysql turned out to be more efficient, partly because neo4j uses Lucene for querying, which treats all payload as text, eventhough this payload was integer. Also with a text payload mysql outperformed neo4j. Though the  researchers also took into account data closer to the real world that has spaces. Surprisinliy, at a large enough scale, neo4j outperformed mysql by a large amount.

\subsubsection{flexibility}
under the flexibility aspect, both database technologies are compared under the aspect of being taken out of the environments for which they were created \citep{Vicknair2010}. For rdbms the uncommon environment is adhoc data schemes that change with time \cite{GarimaAnalysis}. while for graphdb a less typical dataset is one without connections between the nodes
MySQL is optimiged for a large-scale multi-user environment, thats why trying to use it for smaller applications is difficult most of the time, since you have to account for a lot of functionality and also implement it without neccessarily using it. 
Neo4j is typically targeted towards more lightweight application, but manages to scale really well  and has a scalable architecture for speed. \cite{neo4jweb} It has an easily mutable schema.

\subsubsection{security}
Neo4j does not have built in mechanisms for managing security restrictions and multiple users \cite{GarimaAnalysis}.
mySQL natively has multi user support and suppports Access Control Lists

\subsubsection{Maturity}
it makes sense to talk about the database implementations in general now. 
Maturity refers both to how old a particular system is and
to how thoroughly tested it is \cite{Vicknair2010}.
It is important to note taht all relational databases - including mysql- use the same query language SQL, which means that support is equal over all rdbms implementations. Support for one implementation is applicable to all others. \cite{GarimaAnalysis} 
Neo4js version 1.1 was released in February 2010. While neo4j is a for-profit framework and has decent support from its parenty company, this does not apply to all graph database implementations \cite{Vicknair2010}. Furthermore, the query languages differ from implementation to implementation, separating them in that aspect and not sharing support??.

\section{Implementation with Neo4j}
\subsection{Use Case from the SQL world}
\subsection{Installation}
\subsection{modelling}
\subsection{usage, query language}
\subsection{short conclusion, summary}

\section{Reflection}
\subsection{alternative popular graphdbs}
\subsection{conclusion}
reflect on advantages disadvantages with implementation references

